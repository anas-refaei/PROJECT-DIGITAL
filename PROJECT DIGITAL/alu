module alu (
    input  logic [3:0] A,
    input  logic [3:0] B,
    input  logic [3:0] OpCode,
    output logic [3:0] Result,
    output logic Z, N, C, V
);

    logic [4:0] tmp; 
    logic [3:0] eq_r, gt_r;

    alu_eq eq_unit (.A(A), .B(B), .R(eq_r));
    alu_gt gt_unit (.A(A), .B(B), .R(gt_r));

    always @(*) begin
        
        Result = 4'b0000;
        C = 0;
        V = 0;

        case (OpCode)

            4'b0000: begin 
                tmp = A + B;
                Result = tmp[3:0];
                C = tmp[4];
                V = (~(A[3] ^ B[3])) & (A[3] ^ Result[3]);
            end

            4'b0001: begin 
                tmp = A - B;
                Result = tmp[3:0];
                C = tmp[4];
                V = (A[3] ^ B[3]) & (A[3] ^ Result[3]);
            end

            4'b0010: Result = A & B; // AND
            4'b0011: Result = A | B; // OR
            4'b0100: Result = A ^ B; // XOR
            4'b0101: Result = ~A;    // NOT A

            4'b0110: begin // LSL
                Result = A << 1;
                C = A[3];
            end

            4'b0111: Result = A >> 1;   // LSR
            4'b1000: Result = $signed(A) >>> 1; // ASR

            4'b1001: begin // INC A
                tmp = A + 1;
                Result = tmp[3:0];
                C = tmp[4];
                V = (~A[3]) & Result[3];
            end

            4'b1010: begin // DEC B
                tmp = B - 1;
                Result = tmp[3:0];
                C = tmp[4];
                V = B[3] & (~Result[3]);
            end

            4'b1011: Result = B; // PASS B

            4'b1100: Result = eq_r; // EQ
            4'b1101: Result = gt_r; // GT

            default: Result = 4'b0000;

        endcase

        // Common flags
        Z = (Result == 0);
        N = Result[3];

    end

endmodule

