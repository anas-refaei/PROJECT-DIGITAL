module alu (
    input  logic [3:0] A,
    input  logic [3:0] B,
    input  logic [3:0] OpCode,
    output logic [3:0] Result,
    output logic Z,
    output logic N,
    output logic C,
    output logic V
);

    logic [3:0] adder_A;
    logic [3:0] adder_B;
    logic [3:0] adder_sum;
    logic       adder_Cout;
    logic       Cin;

    // Ripple_Carry
    rca4 U1 (
        .A(adder_A),
        .B(adder_B),
        .Cin(Cin),
        .Sum(adder_sum),
        .Cout(adder_Cout)
    );

    always @(*) begin
        
        Result  = 4'b0000;
        Z = 0; N = 0; C = 0; V = 0;

        adder_A = 4'b0000;
        adder_B = 4'b0000;
        Cin     = 0;

        case (OpCode)

            // 0000 : ADD
            4'b0000: begin
                adder_A = A;
                adder_B = B;
                Cin = 0;
                Result = adder_sum;
                C = adder_Cout;
                V = (~(A[3] ^ B[3])) & (Result[3] ^ A[3]);
            end

            // 0001 : SUB
            4'b0001: begin
                adder_A = A;
                adder_B = ~B;
                Cin = 1;
                Result = adder_sum;
                C = adder_Cout;
                V = (~(A[3] ^ B[3])) & (Result[3] ^ A[3]);
            end

            // 0010 : AND
            4'b0010: Result = A & B;

            // 0011 : OR
            4'b0011: Result = A | B;

            // 0100 : XOR
            4'b0100: Result = A ^ B;

            // 0101 : NOT A
            4'b0101: Result = ~A;

            // 0110 : LSL
            4'b0110: begin
                Result = A << 1;
                C = A[3];
            end

            // 0111 : LSR
            4'b0111: Result = A >> 1;

            // 1000 : ASR
            4'b1000: Result = {A[3], A[3:1]};

            // 1001 : INC A
            4'b1001: begin
                adder_A = A;
                adder_B = 4'b0001;
                Cin = 0;
                Result = adder_sum;
                C = adder_Cout;
                V = (A[3] ^ Result[3]);
            end

            // 1010 : DEC B
            4'b1010: begin
                adder_A = B;
                adder_B = 4'b1111;
                Cin = 0;
                Result = adder_sum;
                C = adder_Cout;
                V = (B[3] ^ Result[3]);
            end

            // 1011 : PASS B
            4'b1011: Result = B;

            // 1100 : EQ
            4'b1100: Result = (A == B) ? 4'b0001 : 4'b0000;

            // 1101 : GT (unsigned)
            4'b1101: Result = (A > B) ? 4'b0001 : 4'b0000;

            default: Result = 4'b0000;
        endcase

        // Common flags
        Z = (Result == 4'b0000);
        N = Result[3];
    end
endmodule
