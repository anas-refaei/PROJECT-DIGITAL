module alu_arith (
    input  logic [3:0] A,
    input  logic [3:0] B,
    input  logic [1:0] sel,   // 00 ADD, 01 SUB, 10 INC, 11 DEC
    output logic [3:0] R,
    output logic       C,
    output logic       V
);

    logic [3:0] adder_A;
    logic [3:0] adder_B;
    logic [3:0] sum;
    logic       Cin;
    logic       Cout;

    // Instantiate your ripple carry adder
    rca4 U1 (
        .A(adder_A),
        .B(adder_B),
        .Cin(Cin),
        .Sum(sum),
        .Cout(Cout)
    );

    always @(*) begin
        // defaults
        adder_A = 4'b0000;
        adder_B = 4'b0000;
        Cin     = 1'b0;
        R       = 4'b0000;
        C       = 1'b0;
        V       = 1'b0;

        case (sel)

            2'b00: begin // ADD : A + B
                adder_A = A;
                adder_B = B;
                Cin     = 0;
                R = sum;
                C = Cout;
                V = (~(A[3] ^ B[3])) & (R[3] ^ A[3]);
            end

            2'b01: begin // SUB : A - B = A + (~B) + 1
                adder_A = A;
                adder_B = ~B;
                Cin     = 1;
                R = sum;
                C = Cout;
                V = (A[3] ^ B[3]) & (R[3] ^ A[3]);
            end

            2'b10: begin // INC : A + 1
                adder_A = A;
                adder_B = 4'b0001;
                Cin     = 0;
                R = sum;
                C = Cout;
                V = (~A[3]) & R[3];
            end

            2'b11: begin // DEC : B - 1 = B + 1111
                adder_A = B;
                adder_B = 4'b1111; // -1 in 2's complement
                Cin     = 0;
                R = sum;
                C = Cout;
                V = B[3] & (~R[3]);
            end

        endcase
    end

endmodule
